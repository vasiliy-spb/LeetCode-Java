# Ugly Number II

### от walkccc.me

```Java
public int nthUglyNumber(int n) {
    // Список для хранения уродливых чисел
    List<Integer> uglyNums = new ArrayList<>();
    uglyNums.add(1); // Первое уродливое число - 1

    // Указатели для кратных 2, 3 и 5
    int i2 = 0;
    int i3 = 0;
    int i5 = 0;

    // Генерируем уродливые числа, пока размер списка не достигнет n
    while (uglyNums.size() < n) {
        // Вычисляем следующее уродливое число на основе кратных 2, 3 и 5
        final int next2 = uglyNums.get(i2) * 2;
        final int next3 = uglyNums.get(i3) * 3;
        final int next5 = uglyNums.get(i5) * 5;

        // Найдите минимальное значение среди next2, next3 и next5
        final int next = Math.min(next2, Math.min(next3, next5));

        // Увеличиваем соответствующий указатель, если следующее значение совпадает
        if (next == next2)
            ++i2;
        if (next == next3)
            ++i3;
        if (next == next5)
            ++i5;

        // Добавляем следующее уродливое число в список
        uglyNums.add(next);
    }

    // Возврат n-го уродливого числа
    return uglyNums.get(uglyNums.size() - 1);
}
```

### Объяснение от GPT
Давайте разберем этот подход по шагам:
#### 1. Инициализация:
   - Начните с первого уродливого числа, которое равно 1. Инициализируйте три указателя (`i2`, `i3` и `i5`) для отслеживания следующих кратных 2, 3 и 5.
   - Эти указатели представляют собой индексы в списке уродливых чисел (`uglyNums`), по которым можно найти следующее кратное 2, 3 и 5.

#### 2. Генерация уродливых чисел:
   - Пока размер списка уродливых чисел (`uglyNums`) меньше `n`, продолжайте генерировать новые уродливые числа.
   - Вычислите следующие потенциальные уродливые числа, умножив текущие значения указателей (`i2`, `i3`, `i5`) на 2, 3 и 5 соответственно.

   ```java
   final int next2 = uglyNums.get(i2) * 2;
   final int next3 = uglyNums.get(i3) * 3;
   final int next5 = uglyNums.get(i5) * 5;
   ```

   - Найдем минимальное из этих потенциальных уродливых чисел (`next2`, `next3`, `next5`), и добавим его в список уродливых чисел.

   ```java
   final int next = Math.min(next2, Math.min(next3, next5));
   uglyNums.add(next);
   ```

#### 3. Обновление указателей:
   - Увеличиваем указатели, которые способствовали получению минимального значения, найденного на предыдущем шаге. Это гарантирует, что мы будем двигаться вперед в генерации новых уродливых чисел.

   ```java
   if (next == next2)
       ++i2;
   if (next == next3)
       ++i3;
   if (next == next5)
       ++i5;
   ```

   - Этот шаг очень важен для того, чтобы избежать дублирования значений и эффективно пройти через последовательность уродливых чисел.

#### 4. Возврат результата:
   - Когда размер списка некрасивых чисел достигнет `n`, верните последний элемент списка, который является n-м некрасивым числом.

   ```java
   return uglyNums.get(uglyNums.size() - 1);
   ```

#### Резюме:
   - Данный подход использует тот факт, что каждое новое уродливое число кратно одному из ранее сгенерированных уродливых чисел.
   - Поддерживая указатели и динамически вычисляя следующее потенциальное уродливое число, алгоритм избегает лишних вычислений и эффективно генерирует последовательность уродливых чисел.
   - Использование указателей и минимального вычисления гарантирует, что сгенерированные числа будут расположены в порядке возрастания, удовлетворяя условиям уродливых чисел.

---

### из leetcode solutions:
У нас есть массив k первых n некрасивых чисел. В начале нам известно только первое из них, которое равно 1. Тогда

k[1] = min( k[0]x2, k[0]x3, k[0]x5). Ответ - k[0]x2. Поэтому мы перемещаем указатель 2 на 1. Затем проверяем:

k[2] = min( k[1]x2, k[0]x3, k[0]x5). И так далее. Будьте внимательны к случаям, подобным 6, в которых нам нужно переслать оба указателя на 2 и 3.

Здесь x - это умножение.

На C++:
```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n <= 0) return false; // избавляемся от угловых случаев 
        if(n == 1) return true; // базовый случай
        int t2 = 0, t3 = 0, t5 = 0; //указатели для 2, 3, 5
        vector<int> k(n);
        k[0] = 1;
        for(int i = 1; i < n ; i ++)
        {
            k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5));
            if(k[i] == k[t2]*2) t2++; 
            if(k[i] == k[t3]*3) t3++;
            if(k[i] == k[t5]*5) t5++;
        }
        return k[n-1];
    }
};
```
На Java:
```Java
class Solution {
    public int nthUglyNumber(int n) {
        if (n <= 0) return 0; // избавляемся от угловых случаев 
        if (n == 1) return 1; // базовый случай
        int t2 = 0, t3 = 0, t5 = 0; // указатели для 2, 3, 5
        int[] k = new int[n];
        k[0] = 1;
        for (int i = 1; i < n; i++) {
            k[i] = Math.min(k[t2] * 2, Math.min(k[t3] * 3, k[t5] * 5));
            if (k[i] == k[t2] * 2) t2++; 
            if (k[i] == k[t3] * 3) t3++;
            if (k[i] == k[t5] * 5) t5++;
        }
        return k[n - 1];
    }
}
```

### из комментариев к нему:

* > Позвольте мне попытаться объяснить это на примере. Допустим, у нас есть первые 3 некрасивых числа 1, 2, 3. Каким будет следующее число? Исходя из определения, следующим числом должно быть наименьшее число из 2*(1,2,3), 3*(1,2,3), 5*(1,2,3). Очевидно, что наименьшее число - это 2 * 1 = 2. Но подождите, 2 уже есть. Поэтому, говоря точно, следующим числом должно быть наименьшее из всех существующих чисел, умноженных на 2, 3, 5, которого еще нет в списке. При желании мы можем перебрать все числа и сохранить хеш-сет, но это станет O(N^2). Хорошая новость заключается в том, что мы можем решить эту проблему с помощью DP-подобного подхода. Во-первых, мы предполагаем, что в списке есть только одно число - 1. Следующее число - Min(2 * 1, 3 * 1, 5 * 1)=2, и его нет в списке. Поскольку мы уже рассмотрели 2*1 (переместили указатель на его следующую позицию, которая равна 2), теперь нам нужно рассмотреть только 2*2, 3*1, 5*1 в следующей итерации. Таким образом, нам не нужно беспокоиться о поиске числа, которое уже есть в списке.
> * > То, как вы объяснили, действительно здорово! Просто прочитав несколько строк, я понял это.
Это то же самое, что и K merge sorted, но здесь мы делаем все в линию, т.е.
    1. Создание массивов k
    2. Выбор минимума при построении массива.
> * > Жирная линия помогает прояснить весь алгоритм. Правда, даже если мы переместим указатель в другой список, все равно могут быть дубликаты, так как 2 * 3 == 3 * 2. Так что, вероятно, все равно нужно проверять, есть ли в наборе
> * > Это разъяснено в исходном сообщении - в случаях, когда у вас есть такие вещи, как 23 и 32, ваша проверка min будет выглядеть как Min (2 * 3, 3 * 2, 5 * 2) (поскольку 31 был выбран для 3, 2 * 2 был выбран для 4, а 5 * 1 был выбран для 5). В этом случае упоминается, что нужно увеличить ОБА указателя 2 и указателя 3. Поэтому следующим будет Min(24, 33, 52), то есть выбираем 8. Затем Min(2 * 5, 3 * 3, 5 * 2), то есть выбор 9. Затем Min(2 * 5, 3 * 4, 5 * 2), что является выбором 10. Затем Min(2 * 6, 3 * 4, 5 * 3). В любом случае, когда у вас есть случай повторяющихся чисел, мин умножаемых чисел будет совпадать. Давайте перейдем к выбору 30, где все 3 числа совпадут:
    n=10 (2 * 6, 3 * 4, 5 * 3) выбираем 12, увеличиваем 2 и 3 до следующего некрасивого числа
    n=11 (2 * 8, 3 * 5, 5 * 3) выбираем 15, увеличиваем 3 и 5
    n=12 (2 * 8, 3 * 6, 5 * 4) выбираем 16, увеличиваем 2
    n=13 (2 * 9, 3 * 6, 5 * 4) выбираем 18, увеличение 2 и 3
    n=14 (2 * 10, 3 * 8, 5 * 4) выбираем 20, увеличение 2 и 5
    n=15 (2 * 12, 3 * 8, 5 * 5) выбираем 24, увеличение 2 и 3
    n=16 (2 * 15, 3 * 9, 5 * 5) выбираем 25, увеличение 5
    n=17 (2 * 15, 3 * 9, 5 * 6) выбираем 27, приращение 3
    n=18 (2 * 15, 3 * 10, 5 * 6) выбираем 30, увеличиваем все 3

* > Очень здорово! Я понял общую идею, но мне было трудно понять, как именно работают множественные указатели. Вот тот же алгоритм, но с комментариями и пошаговым описанием - это было особенно полезно, чтобы увидеть, когда несколько указателей перемещаются в одной итерации. Надеюсь, это будет полезно

```Java
public int nthUglyNumber(int n) {
        int p2 = 0, p3 = 0, p5 = 0;
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i < n; i++){
            /* 
                2: currentUglyNumber = min(1 * 2, 1 * 3, 1 * 5) = 2
                    произведено p2, поэтому p2++ 
                    dp [1, 2]
                3: currentUglyNumber = min(2 * 2, 1 * 3, 1 * 5) = 3
                    произведено p3, поэтому p3++
                    dp [1, 2, 3]
                4: currentUglyNumber = min(2 * 2, 2 * 3, 1 * 5) = 4
                    произведено p2, поэтому p2++
                    dp [1, 2, 3, 4]
                5: currentUglyNumber = min(3 * 2, 2 * 3, 1 * 5) = 5
                    произведено p5, поэтому p5++
                    dp [1, 2, 3, 4, 5]
                6: currentUglyNumber = min(3 * 2, 2 * 3, 2 * 5) = 6
                    произведено p2 И p3, поэтому p2++ и p3++
                    dp [1, 2, 3, 4, 5, 6]
                7: currentUglyNumber = min(4 * 2, 3 * 3, 2 * 5) = 8
                    произведено p2, поэтому p2++
                    dp [1, 2, 3, 4, 5, 6, 8]
                8: currentUglyNumber = min(5 * 2, 3 * 3, 2 * 5) = 9
                    получено в p3, поэтому p3++
                    dp [1, 2, 3, 4, 5, 6, 8, 9]
                9: currentUglyNumber = min(5 * 2, 4 * 3, 2 * 5) = 10
                    произведено p2 и p5, p2++ и p5++
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10]
                10: currentUglyNumber = min(8 * 2, 4 * 3, 3 * 5) = 12
                    Обратите внимание на 8, это значение по индексу 6
                    полученное в p3, p3++
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
                11: currentUglyNumber = min(8 * 2, 5 * 3, 3 * 5) = 15
                    произведено p3 и p5, p3++ и p5++
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15]
                12: currentUglyNumber = min(8 * 2, 8 * 3, 4 * 5) = 16
                    произведено p2, p2++
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16]
                13: currentUglyNumber = min(9 * 2, 8 * 3, 4 * 5) = 18
                    произведено p2, p2++   
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18]
                14: currentUglyNumber = min(10 * 2, 8 * 3, 4 * 5) = 20
                    произведено p2 и p5, p2++ p5++   
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20]
                15: currentUglyNumber = min(12 * 2, 8 * 3, 5 * 5) = 24
                    произведено p2 и p3, p2++ p3++   
                    dp [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]
                    
                и т.д. 
            */
            int p2Val = dp[p2] * 2;
            int p3Val = dp[p3] * 3;
            int p5Val = dp[p5] * 5;
            int currentUglyNumber = Math.min(p2Val, Math.min(p3Val, p5Val));
            /* 
                переместите указатель (указатели), который создал currentUglyNumber
                чтобы мы не рассматривали это значение снова
            */
            if (currentUglyNumber == p2Val) p2++;
            if (currentUglyNumber == p3Val) p3++;
            if (currentUglyNumber == p5Val) p5++;
            dp[i] = currentUglyNumber;
        }
        return dp[n - 1];
    }
```

> * > Я тоже так думал в начале, но мы должны четко понимать, что на каждом шаге мы умножаем следующее некрасивое число, а не просто увеличиваем на 1. Так что на 10-м шаге 12 - это некрасивое число 6 * 2, поэтому мы переносим t2 с некрасивого числа 6 на следующее, которое равно 8. Надеюсь, это поможет.

* > 1. По сути, нам нужно умножить существующие уродливые числа на 2, 3 и 5, чтобы получить большее уродливое число, однако если мы будем вслепую умножать все существующие числа на 2, 3 и 5, то число может расти гораздо быстрее, чем нужно.
> 2. Следовательно, каждый раз мы пытаемся найти только следующее наименьшее уродливое число
> 3. Кроме того, поскольку любое существующее число будет умножено на 2, 3 и 5 один и только один раз, иначе оно будет дублироваться, мы можем использовать указатель, чтобы отслеживать, куда будут умножаться 2, 3 и 5 на следующем шаге.
> 4. Как только мы находим следующий минимум, мы можем перемещаться по соответствующему указателю, иначе он всегда остается на уже существующем уродливом числе, что делает указатель бесполезным.
> * > Отличное объяснение. Самая важная часть - "любое существующее число будет умножено на 2, 3 и 5 один и только один раз".

* > Спасибо, что поделились! Я думаю, что этот способ проще для понимания: Чтобы получить новое наименьшее уродливое число, одно из (или некоторые из) 2, 3, 5 должно умножить меньшее уродливое число, и тут в дело вступают указатели. После того как уродливое число получено, соответствующий указатель(и) должен(ны) переместиться вперед. Иначе получится то же самое уродливое число. И порядок сохраняется, поскольку каждое произведение больше или равно предыдущему, и мы каждый раз извлекаем минимум.
> * > Просто чтобы добавить, почему указатели перемещаются, указатели представляют индексы множителей для 2, 3 и 5. Если 2 дает минимальное значение, то с уродливым множителем покончено. Теперь перейдите к следующему множителю для 2. То же самое, если бы это было для 3 или 5.

* > Объяснение с использованием идеи сортировки слиянием.

    > На самом деле три указателя здесь немного запутанны (по крайней мере, для меня). Так что давайте просто уберем указатель. Предположим, у нас есть массив из трех уродливых чисел, которые кратны 2, 3, 5 соответственно.
```
[1, 2, 4, 6, 8, 10, 12, 16, ... ]
[1, 3, 6, 9, 12, 15, 18, 24, ...]
[1, 5, 10, 15, 20, 25, 30, ...]
```
Каждый раз просто находите наименьший в первом столбце, а затем выводите его.
Почему мы можем использовать три указателя? Потому что каждая строка выше образована кратным 2, 3 или 5 числом с другими некрасивыми числами. Их можно переписать в виде
```
2 * [1, 2, 3, 4, 5, 6, 8, ... ]
3 * [1, 2, 3, 4, 5, 6, 8, ... ]
5 * [1, 2, 3, 4, 5, 6, ... ]
```

* > Блестящая идея, вот мое решение для Java:

    ```Java
    public int nthUglyNumber(int n) {
        int[] uglyNumbers = new int[n];
        uglyNumbers[0] = 1;
        int index2 = 0, index3 = 0, index5 = 0;

        for (int i = 1; i < n; i++) {
            // получить некрасивое число путем перемножения всех коэффициентов
            uglyNumbers[i] = Math.min(uglyNumbers[index2] * 2, Math.min(uglyNumbers[index3] * 3, uglyNumbers[index5] * 5));

            // увеличить индекс для текущего минимального числа уродов 
            if (uglyNumbers[i] == uglyNumbers[index2] * 2) index2++;
            if (uglyNumbers[i] == uglyNumbers[index3] * 3) index3++;
            if (uglyNumbers[i] == uglyNumbers[index5] * 5) index5++;
        }

        return uglyNumbers[n - 1];
    }
    ```

* > Это действительно динамическое программирование, поскольку оно повторно использует маленькое уродливое число для построения большого уродливого числа. Если вы все еще не убеждены, я привел ниже реализацию сверху вниз (правда, на Python).
    
    На Python:
   
    ```Python
    class Solution:
        def nthUglyNumber(self, n: int) -> int:

            @lru_cache(None)
            def fn(x):
                """Return the next ugly number to x"""
                if x == 0: return 1
                return min(f*fn(x//f) for f in (2,3,5))

            x = 0
            for _ in range(n): x = fn(x)
            return x
    ```
    На Java:
    ```Java
    class Solution {
        private Map<Integer, Integer> cache = new HashMap<>();

        public int nthUglyNumber(int n) {
            return fn(n);
        }

        private int fn(int x) {
            if (x == 0) return 1;
            if (cache.containsKey(x)) return cache.get(x);

            int result = Integer.MAX_VALUE;
            for (int f : new int[]{2, 3, 5}) {
                result = Math.min(result, f * fn(x / f));
            }

            cache.put(x, result);
            return result;
        }
    }
    ```
    
---

### из leetcode solutions:

Идея этого решения взята с этой страницы: http://www.geeksforgeeks.org/ugly-numbers/.

Уродливая последовательность чисел - 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...
Поскольку каждое число может делиться только на 2, 3, 5, один из способов взглянуть на последовательность - разбить ее на три группы, как показано ниже:

```
(1) 1×2, 2×2, 3×2, 4×2, 5×2, ...
(2) 1×3, 2×3, 3×3, 4×3, 5×3, ...
(3) 1×5, 2×5, 3×5, 4×5, 5×5, ...
```

Мы можем обнаружить, что каждая подпоследовательность является самой уродливой последовательностью (1, 2, 3, 4, 5, ...), умноженной на 2, 3, 5.

Затем мы используем метод слияния, аналогичный сортировке слиянием, чтобы получить каждое уродливое число из трех подпоследовательностей.

На каждом шаге мы выбираем наименьшее из них и двигаемся на шаг вперед, включая числа с одинаковым значением.

Спасибо автору за эту блестящую идею. Вот мое решение на java

```Java
public class Solution {
    public int nthUglyNumber(int n) {
        int[] ugly = new int[n];
        ugly[0] = 1;
        int index2 = 0, index3 = 0, index5 = 0;
        int factor2 = 2, factor3 = 3, factor5 = 5;
        for(int i=1;i<n;i++){
            int min = Math.min(Math.min(factor2,factor3),factor5);
            ugly[i] = min;
            if(factor2 == min)
                factor2 = 2*ugly[++index2];
            if(factor3 == min)
                factor3 = 3*ugly[++index3];
            if(factor5 == min)
                factor5 = 5*ugly[++index5];
        }
        return ugly[n-1];
    }
}
```

### из комментариев к нему:

* > Очень хорошее решение. Однако на первый взгляд оно немного вводит меня в заблуждение. Когда я пытался понять, что "каждая подпоследовательность - это сама уродливая последовательность (1, 2, 3, 4, 5, ...), умноженная на 2, 3, 5". Я автоматически подумал, что последовательность может продолжаться как (1, 2, 3, 4, 5, 6, 7, 8, 9, 10....), лучше было бы перечислить ее как: (1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15). Небольшое предложение.

* > Вот более лаконичный вариант:
```Java
public int nthUglyNumber(int n) {
        int[] nums = new int[n];
        int index2 = 0, index3 = 0, index5 = 0;
        nums[0] = 1;
        for(int i = 1; i < nums.length; i++){
            nums[i] = Math.min(nums[index2] * 2, Math.min(nums[index3] * 3, nums[index5] * 5));
            if(nums[i] == nums[index2] * 2)
                index2++;
            if(nums[i] == nums[index3] * 3)
                index3++;
            if(nums[i] == nums[index5] * 5)
                index5++;
        }
        return nums[n - 1];
    }
```
* > Спасибо, что поделились. Я думаю, что ключ здесь в том, что вы упомянули, "включая числа с одинаковым значением". Фактор2 и фактор3 могут оба иметь значение = 6, но мы сбиваем оба "6" вместе, поэтому дублирование 6 не вызовет никаких проблем. Изначально я выразил это как "else if (factor3==min)", что привело к ловушке :)
* > Отличная идея! Мы также можем просто следить за указателем.

    ```Java
    public int nthUglyNumber(int n) {
        int i = 0, j = 0, k = 0, p = 1;

        int[] dp = new int[n];
        dp[0] = 1;

        while (p < n) {
            dp[p] = Math.min(dp[i] * 2, Math.min(dp[j] * 3, dp[k] * 5));
            if (dp[p] == dp[i] * 2) i++;
            if (dp[p] == dp[j] * 3) j++;
            if (dp[p] == dp[k] * 5) k++;
            p++;
        }

        return dp[n - 1];
      }
    ```
  * > Чтобы избежать возможного недопонимания, я хотел бы написать больше примеров о последовательности чисел.
```
(1) 1×2, 2×2, 3×2, 4×2, 5×2, 6×2, 8×2, ... (Обратите внимание, что здесь нет 7, потому что 7 не принадлежит к числам с уродливым коэффициентом)
(2) 1×3, 2×3, 3×3, 4×3, 5×3, 6×3, 8×3, ...
(3) 1×5, 2×5, 3×5, 4×5, 5×5, 6×5, 8×5, 9×5, ...
```
Ключевая идея заключается в комбинации случайных чисел из {2, 3, 5} и поиске минимума в каждом раунде.
> * > Как вы можете видеть, мы умножаем значение на 2,3,5 =>
так что из этого следует, что мы имеем с 2
=> 2,4,6,8
с 3
=> 3, 6, 9. 12
Аналогично с 5 => так мы никогда не дойдем до случая 7 * 2
> * > Способ, которым они избегают 7, заключается в умножении чисел, уже присутствующих в массиве. Каждый коэффициент умножает последний проверенный индекс этого коэффициента. Проверка чисел в массиве безопасна, потому что мы уже знаем, что эти числа делятся на один из факторов.

* > Ваш код очень лаконичен.
<br> Я просто немного изменил его.
<br> Поскольку java-программа может хранить некоторые статические члены, 
мы можем вычислить все некрасивые числа, которые меньше или равны Integer.MAX_VALUE, и просто сохранить результат в статическом массиве. После некоторых проб я обнаружил, что достаточно получить массив, состоящий из 1691 элемента. (1691-е некрасивое число - 2125764000, а 1692-е - 2147483648, которое просто переполняется).
<br> Например, если нас спросят, какое число является 1691-м, 1690-м, 1689-м, 1688-м, 1687-м, ...., нам не нужно будет вычислять то, что мы уже знаем~ Всего один цикл вычислений, и все, что нам нужно сделать, - это вернуть запрашиваемый элемент в массив.

    ```Java
    public class Solution {
        static int[] ugly = new int[1691];
        static {
            ugly[0] = 1;
            int index2 = 0, index3 = 0, index5 = 0;
            int factor2 = 2, factor3 = 3, factor5 = 5;
            for (int i = 1; i < ugly.length; i++) {
                int min = Math.min(Math.min(factor2, factor3), factor5);
                ugly[i] = min;
                if (factor2 == min)
                    factor2 = 2 * ugly[++index2];
                if (factor3 == min)
                    factor3 = 3 * ugly[++index3];
                if (factor5 == min)
                    factor5 = 5 * ugly[++index5];
            }
        }

        public int nthUglyNumber(int n) {
            return ugly[n - 1];
        }
    }
    ```
> * > Да, если нас спросят, что такое 5-е некрасивое число, то много вычислений будет потрачено впустую.
Но, в общем, тестовые случаи будут достаточно большими.
Кстати, я согласен с вами, алгоритм - это самое главное.

---


